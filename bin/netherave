#!/usr/bin/env php
<?php

use Nether\Console;

use Nether\Avenue\Error\RouteScannerDirInvalid;
use Nether\Avenue\Error\RouteScannerDirUnreadable;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

(function(){

	$CWD = getcwd();
	$Autoloader = sprintf('%s/autoload.php', dirname(__DIR__, 3));

	if(file_exists("{$CWD}/dev.lock"))
	$Autoloader = sprintf('%s/vendor/autoload.php', dirname(__DIR__, 1));

	////////

	//echo "Autoloader: {$Autoloader}", PHP_EOL;
	require($Autoloader);

	return;
})();

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

class App
extends Nether\Console\Client {

	#[Console\Meta\Subcommand]
	#[Console\Meta\Info('Generate a static route map.')]
	#[Console\Meta\SubcommandArg('dir-to-scan', Text: 'Directory to scan for route classes. (default "routes")')]
	#[Console\Meta\SubcommandArg('file-to-write', Text: 'Directory to scan for route classes. (default "routes.phson")')]
	#[Console\Meta\SubcommandOption('--show', Text: 'Show a list of all the routes not just the quick summary.')]
	#[Console\Meta\SubcommandOption('--dry-run', Text: 'Only pretend to do it.')]
	#[Console\Meta\SubcommandOption('--plain', Text: 'No colour.')]
	#[Console\Meta\Error(1, 'unknown error.')]
	#[Console\Meta\Error(2, 'invalid route directory.')]
	#[Console\Meta\Error(3, 'unreadable route directory.')]
	public function
	HandleGen():
	int {

		$Dir = $this->GetInput(2) ?? 'routes';
		$Outfile = $this->GetInput(3) ?? './routes.phson';
		$Scanner = NULL;
		$Show = $this->GetOption('show') ?? FALSE;
		$Route = NULL;

		$F = new Nether\Console\TerminalFormatter;
		$F->Enable(!$this->GetOption('plain'));

		////////

		try {
			$Scanner = new Nether\Avenue\RouteScanner($Dir);
		}

		catch(Throwable $Err) {
			$this->EndOfLine(match(TRUE) {
				($Err instanceof RouteScannerDirInvalid) => 2,
				($Err instanceof RouteScannerDirUnreadable) => 3,
				default => 1
			});
		}

		////////

		static::Message("{$F->BoldYellow('Route Directory:')} {$Dir}");
		static::Message("{$F->BoldYellow('Route File:')} {$Outfile}");
		static::Message();

		$RouteMap = $Scanner->Generate();

		if(!$this->GetOption('dry-run'))
		$RouteMap->Write($Outfile);

		////////

		static::Message("{$F->BoldYellow('Summary:')}");

		$Verb = NULL;
		$Routes = NULL;
		$Route = NULL;

		if($RouteMap['Verbs']) {
			foreach($RouteMap['Verbs'] as $Verb => $Routes) {
				static::Message(sprintf(
					' * %s (%d)',
					$F->BoldYellow($Verb),
					count($Routes)
				));

				if($Show) {
					foreach($Routes as $Route)
					printf(
						'    %s%s%s%s'.
						'        %s %s, %s %s, %s %s%s%s',
						str_replace('\\', $F->Yellow('::'), $Route->Class),
						$F->Yellow('::'),
						$Route->Method,
						PHP_EOL,
							$F->BoldYellow('Verb:'),
							$Route->Verb,
							$F->BoldYellow('Path:'),
							$Route->Path,
							$F->BoldYellow('Domain:'),
							($Route->Domain ?? '<any>'),
						PHP_EOL,
						PHP_EOL
					);

					static::Message();
				}
			}
		}

		if($RouteMap['Errors']) {
			static::Message(sprintf(' * Error Handlers (%d)', count($RouteMap['Errors'])));

			if($Show) {
				foreach($RouteMap['Errors'] as $Verb => $Route) {
					static::Message(sprintf('   %s', $Route->GetCallableName()));
				}

				static::Message();
			}
		}

		////////

		return 0;
	}

}

(new App)->Run();
